●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　●
●　 　　　　      　　　　　GeneralReversi 1.2.1.0 　　　　      　　　　　　○
○　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○

【 ソフト名称 】GeneralReversi
【 ソフト作者 】Yasushi Iwasaki
【 ソフト種別 】FLOSS (Free/Libre and Open Source Software)
【 バージョン 】1.2.1.0
【 リリース日 】2015/11/15
【  開発環境  】Visual Studio 2015
【  開発言語  】C#
【  動作環境  】Windows, Linux, Mac
【   ウェブ   】http://generalreversi.web.fc2.com/
【 リポジトリ 】https://github.com/yasushi-iwasaki/GeneralReversi
【 ライセンス 】GNU General Public License Version 3 or any later
【   メール   】general.reversi@gmail.com

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　　　概要　　　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	リバーシ／オセロを一般化したゲームです。
	何が一般化されているかというと、
	ボードサイズは任意のサイズが選べるようになっており、
	初期配置は交差型と平行型が選べるようになっています。
	もちろん、従来のリバーシ／オセロも「ボードサイズ8の交差型」
	として遊ぶことができます。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　ファイル構成　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	●GeneralReversi.exe
	　本体。

	●ReadMe.txt
	　本書。

	●FFO#40Moves.txt
	　リバーシ／オセロのソルバーを評価するベンチマーク用の棋譜として最も有名なもの[0]。
	　この棋譜をコピーして棋譜入力を行った後、
	　黒プレイヤーとしてソルバープレイヤーを選択し、
	　ソルバープレイヤーの深さを20に設定し、
	　ソルバープレイヤーの順序閾値と置換閾値を適当な値に設定して、
	　スタートすることによりベンチマークを実行することができます。
	　作者の環境では、SolverMTDf-20-6-9が最速になり、7.3秒です。
	　ログを見るとわかりますが、この7.3秒の間に820万回の終局石差計算を行い、
	　白プレイヤーが以後ノーミスでプレイしたとしても、
	　黒プレイヤーが38石勝ちできるということを見抜きます。
	　自分の環境でこのベンチマークを実行してみることをお勧めします。
	　速さはソルバープレイヤーの種別と順序閾値と置換閾値に依存するので、
	　これらを適切に調整することによって最速の設定を探します。
	　最速設定の探し方は以下の通りです。

		①ソルバープレイヤーの種別はSolverTranspositionよりもSolverMTDfの方が高速なのでこちらを設定します。

		②ソルバープレイヤーの順序閾値と置換閾値はまず深さである20に両者設定します。

		③ソルバープレイヤーの順序閾値を20から順に小さくしていき、最速になる値で固定します。

		④ソルバープレイヤーの置換閾値を20から順に小さくしていき、最速になる値で固定します。

	　以上の最速設定の探し方はこのベンチマークの深さである20に限らず、
	　任意の深さに対して適用することができます。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　インストール　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	インストールは必要ありません。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　アンインストール　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	フォルダごと削除してください。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
● 　　　　　　　使用法　　　　　　　 ○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	GeneralReversi.exeを実行するとウィンドウが現れます。
	ウィンドウの左側が設定項目で右側が表示項目になっています。

	●設定項目

		○Start （スタート）
		　ゲームをスタートします。
		　また、ゲームがスタートしている状態ではストップします。
		　ただし、コンピューターが思考中（プログレスバーが進行中）のときは、
		　思考が完了するまではストップしません。
		　しかし、コンピューターが思考中のときであっても、以下のリセットは可能です。

		○Reset （リセット）
		　ゲームをリセットします。

		○Board Size （ボードサイズ）
		　ボードサイズを設定します。
		　用意している選択肢は4から20までですが、2以上の任意の数を設定できます（奇数も可能）。
		　作者の環境であるFullHDディスプレイではウィンドウを最大化すると
		　ボードサイズ180まではプレイ可能でした。
		　大きなディスプレイさえあればこれを超えるボードサイズに対してもプレイ可能です。
		　注意点として、ボードサイズ1は例外処理で既定のボードサイズである8に変更するようにしているので、
		　1から始まる数の場合、例えば100の場合は、クリップボードにコピーしてペーストするか、
		　選択肢から10を選択した状態にしておき、0を加える、などしてください。

		○Initial Pattern （初期配置）
		　交差型（Cross）と平行型（Parallel）の2種類から選択してください。
		　対称性を考えるとこの2種類で必要十分であることがわかります。

		○Black Player （黒プレイヤー）
		　黒プレイヤー（先手プレイヤー）として以下の選択肢から選択してください。

		　	・Human （人間）
			　人間のプレイヤーです。
			　手番になったらボードをクリックすることにより着手できます。

		　	・Random （ランダム）
			　ランダムに着手するプレイヤーです。
			　このプレイヤーが依存する設定項目は以下です。

				＊Random Seed （ランダムシード）

		　	・Monte-Carlo （モンテカルロ）
			　モンテカルロ木探索を行うプレイヤーです。
			　モンテカルロ木探索は囲碁業界で革命を起こしたアルゴリズムで、
			　プレイアウトと呼ばれるランダムプレイヤー同士の対戦を繰り返すことによって
			　着手を決定するアルゴリズムです[1]。
			　このプレイヤーが依存する設定項目は以下です。

				＊Random Seed （ランダムシード）

				＊Monte-Carlo Iteration （モンテカルロイテレーション）

		　	・Alpha-Beta Transposition （アルファベータ置換）
			　置換を利用したアルファベータ法を行うプレイヤーです。
			　アルファベータ法は完全情報ゲームでは基本的なアルゴリズムで、
			　ゲーム木を設定した深さまで探索し、葉ノードで評価関数を利用して評価を行います。
			　相手が相手にとって最善の着手を行うという仮定のもとで、
			　自分が自分にとって最善の着手を行うようにして、
			　葉ノードの評価値を根ノードに向かって伝搬させていきます。
			　このアルファベータ法に対して置換を利用するようにするとより効率が良くなります。
			　つまり、以前に訪問した局面が現れた場合にはその情報を利用します。
			　このプレイヤーが依存する設定項目は以下です。

				＊Random Seed （ランダムシード） ※ランダム性をオンにしている場合のみ

				＊Evaluation Function （評価関数）

				＊Alpha-Beta Depth （アルファベータ深さ）

				＊Alpha-Beta Order Threshold （アルファベータ順序閾値）

				＊Alpha-Beta Transposition Threshold （アルファベータ置換閾値）

		　	・Alpha-Beta MTDf
			　MTD(f)を行うプレイヤーです。
			　MTD(f)とは「Memory-enhanced Test Driver with first guess f」の略で、
			　「Alpha-Beta Transposition」を利用したアルゴリズムです[2]。
			　評価値の存在範囲を徐々に絞っていくことにより、
			　最終的に評価値と着手を決定します。
			　このプレイヤーが依存する設定項目は同上です。

		　	・Iterative-Deepening Transposition （反復深化置換）
			　深さを1から順に設定した深さまで反復深化させます。
			　特定の深さでの探索には「Alpha-Beta Transposition」を利用します。
			　特定の深さでの探索時に、それ以前の深さでの探索の置換を利用することができます。
			　このプレイヤーが依存する設定項目は以下です。

				＊Random Seed （ランダムシード） ※ランダム性をオンにしている場合のみ

				＊Evaluation Function （評価関数）

				＊Iterative-Deepening Depth （反復深化深さ）

				＊Iterative-Deepening Order Threshold （反復深化順序閾値）

				＊Iterative-Deepening Transposition Threshold （反復深化置換閾値）

		　	・Iterative-Deepening MTDf
			　深さを1から順に設定した深さまで反復深化させます。
			　特定の深さでの探索には「Alpha-Beta MTDf」を利用します。
			　特定の深さでの探索時に、それ以前の深さでの探索の置換を利用することができ、
			　直前の深さでの評価値を初期値として探索することができます。
			　このプレイヤーが依存する設定項目は同上です。

		　	・Solver Transposition
			　「Alpha-Beta Transposition」を利用したソルバープレイヤーです。
			　空マスの数が設定した深さになると完全読みを行います。
			　それ以前は設定したベースプレイヤーにより着手を行います。
			　このプレイヤーが依存する設定項目は以下です。

				＊Random Seed （ランダムシード） ※ランダム性をオンにしている場合のみ

				＊Solver Base Player （ソルバーベースプレイヤー）

				＊Solver Depth （ソルバー深さ）

				＊Solver Order Threshold （ソルバー順序閾値）

				＊Solver Transposition Threshold （ソルバー置換閾値）

		　	・Solver MTDf
			　「Alpha-Beta MTDf」を利用したソルバープレイヤーです。
			　空マスの数が設定した深さになると完全読みを行います。
			　それ以前は設定したベースプレイヤーにより着手を行います。
			　このプレイヤーが依存する設定項目は同上です。

		○White Player （白プレイヤー）
		　白プレイヤー（後手プレイヤー）として選択肢（同上）から選択してください。

		○Last Position （直近の着手位置）
		　直近の着手位置をピンク色のマスにして表示します。

		○Movable Positions （着手可能位置）
		　着手可能位置を水色のマスにして表示します。

		○Pass Message Box （パスメッセージボックス）
		　パスの際にメッセージボックスを表示します。

		○Delay Time [ms] （遅延時間）
		　手番交替の際に遅延させる時間を設定します。
		　コンピューター同士の対戦をゆっくり観戦する場合などに利用します。

		○History （履歴）
		　任意のフェーズの局面を表示させることができます。
		　また、スタートを押すことによりその局面からスタートすることができます。
		　なお、履歴を一つ戻したり進めたりという操作はマウスで行うよりも、
		　矢印キーを利用すると便利です（上下キーまたは左右キー）。

		○Random Seed （ランダムシード）
		　乱数の種を変更します。
		　一番上の選択肢はコンピューターを起動してからの経過時間[ms]であり、
		　ランダムシードとして利用できます。
		　以降は1から9までの数が選択肢として用意してあります。
	　	　ランダム性を持つプレイヤーは、ランダムシードによって着手が変わります。
	　	　逆に言えば、同じランダムシードを設定すれば、着手が再現できます。

		○Monte-Carlo Iteration （モンテカルロプレイヤーのイテレーション）
	　	　モンテカルロプレイヤーのイテレーション（プレイアウトの回数）です。
		　大きい値を設定すれば強くなりますが、時間もかかるようになります。

		○Evaluation Function （評価関数）
	　	　葉ノードの局面を評価する関数です。

			・Score （スコア）
			　石差を評価値として返します。

			・Movable （ムーバブル）
			　着手可能位置数の差を評価値として返します。

			・Corner （コーナー）
			　隅の数の差とムーバブルを考慮した評価値を返します。

			・Stable （ステイブル）
			　重み付きの確定石の数の差とムーバブルを考慮した評価値を返します。

		○Alpha-Beta Depth （アルファベータプレイヤーの深さ）
	　	　アルファベータ法で探索する深さです。

		○Alpha-Beta Order Threshold （アルファベータプレイヤーの順序閾値）
	　	　アルファベータ法で着手可能位置の探索の順番を良さそうな手からにする閾値です。
		　この設定項目を変更してもプレイヤーの強さは変わりませんが、速さが変わります。
		　まず、この設定項目を深さと同じ値にすると並べ替えを行いません。
		　次に、この設定項目を深さ-1にすると最初の1手のみ並べ替えを行います。
		　同様に、この設定項目を深さ-2にすると最初の2手のみ並べ替えを行います。
		　このように、この設定項目を段々小さくしていくことにより速くなっていきます。
		　しかし、あるところからは逆に遅くなっていきます。
		　なので、最も速くなる値は1と深さの間にあります。
		　調査して最適値がわかったら、その値を設定します。
		　調査方法としては、ランダムプレイヤーを対戦相手としてプレイ時間を計測するのが良いでしょう。

		○Alpha-Beta Transposition Threshold （アルファベータプレイヤーの置換閾値）
	　	　アルファベータ法で置換を利用する閾値です。
		　この設定項目を変更してもプレイヤーの強さは変わりませんが、速さが変わります。
		　まず、この設定項目を深さと同じ値にすると置換を利用しません。
		　次に、この設定項目を深さ-1にすると最初の1手のみ置換を利用します。
		　同様に、この設定項目を深さ-2にすると最初の2手のみ置換を利用します。
		　このように、この設定項目を段々小さくしていくことにより速くなっていきます。
		　しかし、あるところからは逆に遅くなっていきます。
		　なので、最も速くなる値は1と深さの間にあります。
		　調査して最適値がわかったら、その値を設定します。
		　調査方法としては、ランダムプレイヤーを対戦相手としてプレイ時間を計測するのが良いでしょう。

		○Alpha-Beta Random （アルファベータプレイヤーのランダム性）
		　アルファベータプレイヤーにランダム性を持たせます。

		○Iterative-Deepening Depth （反復深化プレイヤーの深さ）
		　反復深化法で探索する深さです。

		○Iterative-Deepening Order Threshold （反復深化プレイヤーの順序閾値）
		　反復深化法で着手可能位置の探索の順番を良さそうな手からにする閾値です。
		　「Alpha-Beta Order Threshold」と同様なのでそちらを参照してください。

		○Iterative-Deepening Transposition Threshold （反復深化プレイヤーの置換閾値）
		　反復深化法で置換を利用する閾値です。
		　「Alpha-Beta Transposition Threshold」と同様なのでそちらを参照してください。

		○Iterative-Deepening Random （反復深化プレイヤーのランダム性）
		　反復深化プレイヤーにランダム性を持たせます。

		○Solver Base Player （ソルバープレイヤーのベースプレイヤー）
		　ソルバープレイヤーのベースプレイヤーを選択します。
		　選択した後は、そのプレイヤーの設定項目も設定してください。

		○Solver Depth （ソルバープレイヤーの深さ）
		　ソルバーで探索する深さです。

		○Solver Order Threshold （ソルバープレイヤーの順序閾値）
		　ソルバーで着手可能位置の探索の順番を良さそうな手からにする閾値です。
		　「Alpha-Beta Order Threshold」と同様なのでそちらを参照してください。

		○Solver Transposition Threshold （ソルバープレイヤーの置換閾値）
		　ソルバーで置換を利用する閾値です。
		　「Alpha-Beta Transposition Threshold」と同様なのでそちらを参照してください。

		○Solver Random （ソルバープレイヤーのランダム性）
		　ソルバープレイヤーにランダム性を持たせます。

		○Clear Memory （メモリークリア）
		　現在設定されている、黒プレイヤー、白プレイヤー、ソルバープレイヤーのベースプレイヤー、において、
		　メモリーに登録されている置換をクリアします。

		○Input Moves （棋譜入力）
		　棋譜の入力を行います。

		○Output Moves （棋譜出力）
		　棋譜の出力を行います。

	●表示項目

		○Boardタブ
		　ボード関連の情報を表示します。

			・ボード表示
			　現在のボードを表示します。

			・スコア・手番表示
			　現在のスコアと手番を表示します。

			・フェーズ表示
			　現在のフェーズを表示します。

			・状況表示
			　現在の状況（着手や勝敗）を表示します。

			・進捗表示
			　現在の進捗（割合やループ）を表示します。

		○Logタブ
		　ゲーム進行のログを表示します。
		　「右クリック→すべて選択→コピー」により
		　ログをコピーしてテキストファイルに保存することができます。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　　　雑記　　　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	●起動時オプション

	　	○GeneralReversi.exeを起動するときに「Ctrlキーを押しながら」にすると、
		　（コマンドラインでは「GeneralReversi.exe log」と入力すると、）
	　	　「ボード」タブではなく、「ログ」タブが、表示された状態で起動します。
		　通常起動するとボードが表示されることにより、リバーシ／オセロをしていることが
		　周囲の人に認識される可能性がありますが、このオプションを利用することにより、
		　その可能性を排除できます。
		　作者はこれを利用して会社のハイスペックマシンでボードサイズ6の解法を行いました＾＾；
		　詳しくはウェブで！

	　	○GeneralReversi.exeを起動するときに「Shiftキーを押しながら」にすると、
		　（コマンドラインでは「GeneralReversi.exe ffo」と入力すると、）
	　	　コンソールでFFOを実行します。
		　FFOは#40（20手読み）から#48（25手読み）までの9種類で、
		　作者の環境で全部完了するまでには30分程度かかります。
		　ソルバープレイヤーで20手以上の深い読みを設定するときの目安にしてください。

	●同じプレイヤー同士の対局
	　コンピューターの同じプレイヤー同士の対局を、違う設定で行うことは仕様上できません。
	　例えば、深さ5のアルファベータプレイヤーと深さ10のアルファベータプレイヤーの対局を行うことはできません。
	　ただ、同じ設定であれば行うことはできますし、
	　どうしてもという場合には、GeneralReversiを2つ起動して、人間が仲介することによって行うことはできます。

	●待った
	　コンピューターと対局していて「待った」をしたいときは履歴機能を利用してください。
	　具体的には、直近の手のみの「待った」であれば今のフェーズから2を引いたフェーズに設定してください。
	　通常のボードゲームソフトでは「最初へ戻る」、「戻る」、「進む」、「最後へ進む」、
	　の機能が備わっていることが多いですが、
	　GeneralReversiでは履歴機能によって任意のフェーズにジャンプすることができるようにしています。
	　これは、例えばボードサイズが100の場合は終局フェーズは最低でも9996であり、
	　ここからフェーズ5000に戻したいといった場合に、1つ1つ戻していたのでは大変だからです。
	　また、相手の手番に戻して、相手プレイヤーの設定を変えたり、プレイヤー自体を変えるといったことも可能です。

	●マスの位置
	　通常のボードサイズ8のリバーシ／オセロでは左上を基準にして、
	　左右方向にアルファベットのAからHで、
	　上下方向に数字の1から8で、
	　マスの位置を表現します。
	　しかし、任意のボードサイズでマスの位置を表現するためには
	　アルファベットでは役不足です。
	　そこで、左右方向に関しても数字で表現します。
	　また、数字の最初は1ではなく0とします。
	　さらに、二つの数字を列挙する順番を上下方向→左右方向とします。
	　つまり、行列表現です。
	　いくつか例を示します。

		○D3：(2, 3)

		○C4：(3, 2)

		○F5：(4, 5)

		○E6：(5, 4)

	●棋譜
	　ゲームを途中で中断して後で再開する場合や、
	　ゲームの終了後に後で振り返る場合などには、
	　棋譜の出力と入力を行います。
	　棋譜を出力したら、コピーしてテキストファイルを作成します。
	　（付属のFFO#40Moves.txtは棋譜のテキストファイルです。）
	　再開時や振り返り時にはそのテキストファイルを開き、
	　コピーして棋譜の入力を行います。
	　棋譜のフォーマットは人間にもわかりやすいものとなっています。
	　最初の一行にボードサイズと初期配置を記述し、以降の行では、
	　左側に先手である黒の着手を、右側に後手である白の着手を、記述します。

	●ウィンドウサイズ
	　起動時のウィンドウサイズは1200×900に設定しています。
	　ウィンドウサイズのリサイズは可能ですが、このサイズ以上でのご使用を推奨します。
	　解像度が低いディスプレイではそれに合わせたウィンドウサイズで起動しますが、
	　設定項目の表示が乱れる場合があります。

	●数あるリバーシ／オセロソフトの中でのGeneralReversiの特徴
	　世の中には無数のリバーシ／オセロソフトが存在します。
	　それらの多くは「強さ」に主眼を置いています。
	　しかしGeneralReversiは「一般化」に主眼を置いています。
	　「強さ」に主眼を置いたソフトの多くは「棋譜からの学習」を行います。
	　ここで「棋譜」は人間同士の対局のものや、人間対コンピューターの対局のもの、
	　コンピューター対コンピューターの対局のもの、など様々ですが、
	　共通して言えることは「棋譜という歴史的資産を利用して強くなる」ということです。
	　では歴史がないゲームについてはどうしたらいいでしょうか。
	　例えば「ボードサイズ8の平行型」や「ボードサイズ10」などです。
	　これらについては棋譜という歴史的資産がないため、学習を行うことができません。
	　自己対局により学習を行うことも可能なのですが、
	　無限のゲームの種類を想定しているので、敬遠せざるを得ません。
	　「一般化」に主眼を置いていると言っても人間が戦ってそれなりに手応えのある
	　コンピュータープレイヤーを作る必要があります。
	　そこで作者がとったアプローチは一般化リバーシに適用できるアルゴリズムの「選択」と「構築」です。
	　具体的に「選択」というのは「モンテカルロ木探索」のことを表しています。
	　アルファベータ法や反復深化法は基本的な手法として知れ渡っていましたが、
	　モンテカルロ木探索をリバーシ／オセロに適用したという例は見たことがありません。
	　モンテカルロ木探索は評価関数が不要という性質に加えて、
	　イテレーションを十分に大きくすれば最善の着手を行うことができるということが証明されています[1]。
	　（石差が最大の着手は行えないが、勝率が最大の着手は行える。つまり、必勝ゲームに対しては必ず勝てる。）
	　実際に、ボードサイズ4の場合は白必勝のゲームなのですが、
	　白プレイヤーとしてモンテカルロ木探索プレイヤーを選択し（イテレーションは10000）、
	　黒プレイヤーとしてソルバープレイヤーを選択しても（ランダム性はオン）、
	　モンテカルロ木探索プレイヤーは必ずソルバープレイヤーに勝つことができます。
	　しかし、モンテカルロ木探索は理論は非常に美しいのですが、速さの面で実用性に難がありました。
	　具体的には、ボードサイズ8の場合はそれほどリバーシ／オセロが強くない作者であっても勝ててしまいます＾＾；
	　そこで「構築」の話ですが、一般化リバーシ用にオリジナルの評価関数「Stable」を構築しました。
	　重み付きの確定石の数の差とムーバブルを考慮した評価値を返します。
	　この評価関数を利用したアルファベータや反復深化には作者は勝てなくなりました＾＾；
	　めでたし、めでたし？

	●ゲームの解法
	　2007年にチェッカーが解かれたという論文がScienceに掲載され話題になりました[3]。
	　詳しくは読んでないですが、要約によると1989年から回し続けていたようですから、
	　20年近くかけてようやく解くことができたみたいです。
	　さて、リバーシ／オセロに関してはどうかというと、2014年現在では解かれていません。
	　ボードサイズ8の解法は難しいかもしれないが、ボードサイズ6なら簡単に解法できそう・・・、
	　そんなふうに考えていた時期が俺にもありました＾＾；
	　単純なアルファベータ法をプログラムし、まずはボードサイズ4の解法にチャレンジ。
	　これは比較的すぐに解くことが出来ました。
	　次はボードサイズ6の解法にチャレンジ。
	　しかし、いっこうに解ける気配がありません。
	　調べてみると1993年に交差型は2週間、平行型は5週間かけて解かれているということがわかりました[4]。
	　それから20年以上経ってコンピューターの性能もアップしているわけだし、すぐに解けないものでしょうか。
	　さらに調べてみると英語版Wikipediaの「Computer Othello」のページにて、
	　「ボードサイズ6のオセロは単純なミニマックス法で100時間以内に解ける」という記述を発見[5]。
	　なぜアルファベータ法よりも効率が悪いミニマックス法を使ってるんだ？という疑問は残りつつも、
	　ミニマックス法で100時間ならアルファベータ法にすればもっと速くなる、と確信する。
	　そしてGeneralReversiの開発において高速性を重要視するようになる。
	　アプローチとしては、ボードサイズ8の速さをFFO#40をベンチマークとして改善し、
	　結果として任意のボードサイズの速さが改善する、という方法をとりました。
	　開発初期ではFFO#40に1800秒かかっていましたが、最終的に7.3秒になりましたので、
	　250倍高速化できた、ということになります。
	　プログラミングの一般論としての高速化も勉強になりましたし[6]、
	　リバーシ／オセロプログラミング特有の先人の知恵なども勉強になりました[7]。
	　最終的にボードサイズ6は一日かからずに解くことができるようになりました。
	　めでたし、めでたし？

	●開発の経緯

	　	①Mathematicaの動的インタラクティブ機能で一般化したリバーシを作って、
		　デモンストレーションサイトに投稿しようと思い立つ。

		②一般化リバーシのゲーム機能とアルファベータ法をMathematicaで実装する。

		③アルファベータ法でボードサイズ6の解法を試みるも失敗。

		④モンテカルロ木探索というアルゴリズムの存在を知り実装する。

		⑤アルファベータ法（＋評価関数）もモンテカルロ木探索も弱かったが（作者が勝てる）、
		　特に改善もせず投稿し採択される[8]。

		⑥約2年が経過。

		⑦C#を勉強しようと思い立つ。

		⑧一通りC#を勉強し終えた後[9]、実践的な勉強として一般化リバーシを作成しようと思い立つ。

		⑨Mathematicaではなし得なかった「速さ」と「強さ」の実現を図る。

		⑩作者が自作のプログラムに負ける（嬉しくもあり悲しくもある。娘を嫁にやる気分？）。

		⑪ボードサイズ6を一日かからずに解くことができるようになる。

		⑫初版リリース。

	●各プレイヤーの速さと強さ

		○「Random」
		　説明不要だと思いますが、着手可能位置の中からランダムに着手しているだけです。
		　速さは一瞬で、このためプログレスバーでの進捗表示も行いません。
		　強さは最弱で、初心者であっても負けることはまずないでしょう。

		　作者による強さの評価：「最弱」

		○「Monte-Carlo」
		　初めて論文[1]を読んだときは非常にワクワクしたのを覚えています。
		　評価関数が不要という性質に加えて、
	　	　イテレーションを十分に大きくすれば最善の着手を行うことができる、
		　なんて素敵なアルゴリズムだ、と。
		　しかし、実際に実装してみるとそれほど強くはありませんでした。
		　イテレーションを大きくすれば強くなるのは事実なのですが、
		　現実的に待てる時間というのは限られています。
		　ボードサイズ8に関して言えば、イテレーション10000まではストレスなく対局できますが、
		　作者よりも弱いです。
		　少し待ち時間がかかるのを我慢してイテレーション100000とも対局してみましたが、
		　やはり作者よりも弱いです。

		　作者による強さの評価：「弱」

		○「Alpha-Beta」と「Iterative-Deepening」
		　アルファベータと反復深化は置換とMTD(f)の別で計4種類ありますが、
		　深さが一緒なら強さも一緒になります。
		　強さが一緒なら速い方がいいに決まっています。
		　作者が速さを評価したところ、速い方から順に以下のようになりました。

			・Alpha-Beta MTDf

			・Alpha-Beta Transposition

			・Iterative-Deepening MTDf

			・Iterative-Deepening Transposition

		　なので、これら4種類の中では「Alpha-Beta MTDf」を選択すればよいでしょう。
		　ただ、「Alpha-Beta MTDf」はプログレスバーでの進捗表示が割合を表示しているのではなく、
		　「思考中ですよ！」ということを表すために床屋さんの看板のようにグルグル回ります。
		　そして思考が終わると突然止まります。
		　なので、遅くても進捗表示が割合で表示される方がいい、という場合は他のプレイヤーを選択してください。
		　ただ、「Alpha-Beta MTDf」は「ログ」タブを表示すれば「思考中ですよ！」以上の情報を得ることができます。
		　強さについては、作者は深さ10（評価関数はStable）には勝てません。
		　速さについては、深さ10の場合であってもストレスなく対局することができます。
		　参考までに、作者が速さを評価した際の深さ10の場合の最速設定を載せておきます。

			・プレイヤー：Alpha-Beta MTDf

			・深さ　　　：10

			・順序閾値　：3

			・置換閾値　：3

		　作者による強さの評価：「強」

		○「Solver」
		　ソルバープレイヤーはコンピューターの計算能力をフル活用したプレイヤーです。
		　ボードサイズ8のリバーシ／オセロでは全64マスのうち初期配置の4マスを除いた
		　60マスに両者が着手を行うことになります。
		　この60マスのうち、最初の20手を「序盤」、中間の20手を「中盤」、最後の20手を「終盤」、
		　と呼びますが、ソルバープレイヤーでは終盤を完全に読み切ることができます。
		　なので、対局相手は序盤・中盤で有利な状態にしておき、なおかつ終盤ではミスを最小限に抑える必要があります。
		　強さについては、ベースプレイヤーにもよりますが、ベースプレイヤーが上記の設定であれば、
		　人間は勝てないのではないでしょうか。
		　速さについては、深さ20の場合であってもストレスなく対局することができます。
		　参考までに、作者が速さを評価した際の深さ20の場合の最速設定を載せておきます。

			・プレイヤー　　　：Solver MTDf

			・深さ　　　　　　：20

			・順序閾値　　　　：6

			・置換閾値　　　　：9

			・ベースプレイヤー：上記の「Alpha-Beta MTDf」の最速設定

		　上記の設定でゼブラと対局させてみたところ、「中盤8手読み―完全16手読み―勝敗18手読み」に対して
		　たまに勝てる程度でした。

		　作者による強さの評価：「最強」

	●マルチプラットフォーム
	　「Visual Studio」で開発したプログラムはWindowsでしか動かないと思っていませんか？
	　実はそんなことないんです。
	　開発言語であるC#は標準化団体によって標準化されており、誰でも処理系を作ることは可能なんです。
	　ただ、Windowsの開発元であるMicrosoftが例えばLinux向けの処理系を作成することはありませんでした。
	　その状況を打開したのがLinuxにおけるデスクトップ環境GNOMEの開発者として知られるイカザでした。
	　彼は「Mono」という.NET互換の環境を実現するオープンソースソフトウェアを開発しました[10]。
	　作者はGeneralReversiの開発において、当初Windowsのみをターゲットとしていました。
	　ですが、Monoの存在は知っており、モノは試しということでLinuxにMonoをインストールし、
	　GeneralReversiを実行してみました。
	　すると、なんといきなり動いたではありませんか！
	　細かいところで挙動が違うということはありましたが、大した問題ではありません。
	　大した問題ではありませんが、将来の修正を期待して、Monoプロジェクトに対してバグ報告をしておきました。

		○CheckBox with button appearance can not align text in Linux (Windows can) [11]

		○TextBox with tab text can not show correctly in Linux (Windows can) [12]

	　バージョン1.2.0.0より、Mono環境（Linux, Mac, etc.）に対応しました。
	　少し脱線しますが、作者が好きなイカザの言葉を紹介します。
	　「Cでプログラミングするには人生は短すぎる（Life is too short to code in C.）」
	　つまり、「C#を使え！」ってことです。
	　しかし、当の本人イカザは処理系を作っているわけですからCから離れることはできません。
	　つまり、自分が犠牲になって人生を短くすることによって、今後の人類の人生を長くしてくれているのです！
	　神様！仏様！イカザ様！に感謝！

	●オープンソース
	　GeneralReversiはバージョン1.2.0.0より前はソースコードを公開していませんでしたが、
	　バージョン1.2.0.0のリリースに際してGitHubに公開リポジトリを作成しました。
	　ライセンスはGPLv3または全後方とします。
	　神様！仏様！ストールマン様！に感謝！

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　　　参考　　　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	[0]http://www.radagast.se/othello/ffotest.html
	　 FFOテスト。
	　 リバーシ／オセロソフトの中では日本で一番有名なゼブラの作者が、
	　 ゼブラの速さを自慢するために作ったベンチマークテスト集。

	[1]http://ci.nii.ac.jp/naid/110006782380
	　 「モンテカルロ木探索 : コンピュータ囲碁に革命を起こした新手法」という論文。
	　 9路盤での対局ではあるが、モンテカルロ木探索を用いたソフトがプロ棋士から1勝を挙げた。
	　 公の場でコンピューターがプロ棋士に勝つことは史上初の快挙である。

	[2]http://people.csail.mit.edu/plaat/mtdf.html
	　 MTD(f)の提案者によるアルゴリズム説明。
	　 チェス、チェッカー、リバーシ／オセロなどで、
	　 従来の最速手法であったNegaScout/PrincipalVariationよりも高速であることが示されている。

	[3]http://www.sciencemag.org/content/317/5844/1518.abstract
	　 「Checkers Is Solved」という論文。
	　 1989年から回し続けて、20年近くかけてようやく解法。

	[4]https://www.maths.nottingham.ac.uk/personal/jff/
	　 ページ下部にOthelloという項目がある。
	　 イギリスのオセロチャンピオンに6回もなっている人で、本業は数学者（大学の准教授）。
	　 ボードサイズ6の解法に関する記事はフィクション仕立て。

	[5]http://en.wikipedia.org/wiki/Computer_Othello
	　 「Solving Othello」の「Othello 6 x 6」の項目に次のような記述がある。
	　 Othello 6x6 has been solved in less than 100 hours 
	　 by many simple Othello programs that use the Minimax method, 
	　 which generates all possible positions (nearly 3.6 trillion).

	[6]http://www.dd.e-mansion.com/~kumada/laboratory/column/java_perf.html
	　 「性能を考慮したJavaのプログラミング」。
	　 開発言語はC#ですが、Javaと共通する事柄は多く、とても参考になりました。
	　 書籍「Javaの鉄則」をもとに、参考になると思ったものが紹介されています。

	[7]http://www.amy.hi-ho.ne.jp/okuhara/howtoj.htm
	　 「強いオセロプログラムの内部動作」。
	　 ゼブラ作者が書いた記事の日本語訳。
	　 リバーシ／オセロプログラミングにおける重要事項がコンパクトにまとめられており、とても参考になりました。

	[8]http://demonstrations.wolfram.com/Reversi/
	　 Mathematicaで作った動的インタラクティブを収集・掲載する
	　 「ウルフラムデモンストレーションサイト」。
	　 作者も一般化リバーシを作成して投稿し採択された。

	[9]http://www.atmarkit.co.jp/fdotnet/csharp_abc/index/
	　 C#のプログラミング入門。
	　 合い言葉は“Let's See Sharp!”。
	　 作者はこれを読んでC#がとても好きになりました。

	[10]http://www.mono-project.com/
	    .NET互換の環境を実現するMonoプロジェクト。
	    Windows以外のOS、例えばLinuxやMacでもMonoをインストールすればC#で書かれたプログラムを実行できる。
	    「Cでプログラミングするには人生は短すぎる（Life is too short to code in C.）」ので、C#を使いましょう！

	[11]https://bugzilla.xamarin.com/show_bug.cgi?id=35443
	    「CheckBox with button appearance can not align text in Linux (Windows can)」というバグ報告。
	    GeneralReversiをMonoで実行するとStartボタンだけ左揃えになってしまう。
	    これはStartボタンが他のボタンと違って外観をボタンにしたCheckBoxだからである。
	    ソースコードではちゃんと中央揃えを指定しているため、こればかりはバグを修正してもらわないと直らない。

	[12]https://bugzilla.xamarin.com/show_bug.cgi?id=35444
	    「TextBox with tab text can not show correctly in Linux (Windows can)」というバグ報告。
	    GeneralReversiをMonoで実行するとLogタブ内のタブを含むテキストが正しく表示されない。
	    コピーしてテキストファイルに保存することは問題ないため、
	    正しく表示したければエディタなどを利用してください。

	[13]https://github.com/yasushi-iwasaki/GeneralReversi
	    GitHubにおけるGeneralReversiの公開リポジトリ。
	    ライセンスはGPLv3または全後方とします。

●○●○●○●○●○●○●○●○●○●○
○　　　　　　　　　　　　　　　　　　●
●　　　　　　　　履歴　　　　　　　　○
○　　　　　　　　　　　　　　　　　　●
●○●○●○●○●○●○●○●○●○●○

	●2014/12/31	1.0.0.0
	　初版リリース。

	●2015/02/21	1.0.1.0

		○Stopボタンを押してもスレッドが停止しない場合があるバグを修正した。

		○Humanプレイヤーの手番で終了または棋譜入力後のボード反映中に終了するとプロセスに残るバグを修正した。

	●2015/03/15	1.1.0.0

		○高速化した（作者の環境でFFO#40が9.3秒から7.7秒になった。）。

		○「Shiftキーを押しながら」起動するとコンソールでFFOを実行する機能を追加した。

	●2015/04/06	1.1.1.0

		○Startボタンが押下されている状態でリサイズができなかったバグを修正した。

		○ウィンドウサイズを小さくすると設定不可能になる項目が出現するバグを修正した。

	●2015/04/13	窓の杜のダイジェストニュースで紹介された。
	　http://www.forest.impress.co.jp/docs/digest/20150413_697561.html

	●2015/11/02	1.2.0.0

		○リサイズ時に選択されているタブ以外のタブが適切にリサイズされないバグを修正した。

		○リサイズ時に探索中だとそのボードが反映されてしまうバグを修正した。

		○パスメッセージボックス表示時に履歴コンボボックスを開いていると例外が発生するバグを修正した。

		○Startボタンが押下されている状態で履歴を参照すると不正な場合があるバグを修正した。

		○開発環境を「Visual Studio 2013」から「Visual Studio 2015」に移行した。
		　コンパイラーの性能向上によりFFO#40が7.7秒から7.3秒になった。
		　Microsoft, Good Job!

		○棋譜のフォーマットを変更した。
		　人間が見てわかりやすいフォーマットにした。
		　最初の一行にボードサイズと初期配置を記述し、以降の行では、
		　左側に先手である黒の着手を、右側に後手である白の着手を、記述する。
		　この際、旧フォーマットでは記述しなかったパスも記述する。
		　なお、旧バージョンに新フォーマットを読み込ませることも可能であるし（前方互換性）、
		　新バージョンに旧フォーマットを読み込ませることも可能である（後方互換性）。
		　つまり、相互互換性がある。

		○サブウィンドウにもGeneralReversiアイコンを設定した。

		○メッセージボックスの利用をやめサブウィンドウを統一した。

		○起動時オプションをコマンドライン引数でも指定できるようにした。

		○マルチプラットフォーム化した。

			・コンソールのFFO機能を「Windows 10」および「Ubuntu Linux」へ対応した。

			・.NETでは正常に動作するがMonoでは異常となるバグを報告した。

				＊CheckBox with button appearance can not align text in Linux (Windows can)

				＊TextBox with tab text can not show correctly in Linux (Windows can)

		○オープンソース化した。

			・GitHubに公開リポジトリを作成した。

			・ライセンスはGPLv3または全後方とする。

	●2015/11/09	窓の杜のダイジェストニュースで紹介された。
	　http://www.forest.impress.co.jp/docs/digest/20151109_729667.html

	●2015/11/15	1.2.1.0

		○起動直後またはリセット直後に履歴でフェーズ0を選ぶと例外が発生するバグを修正した。

		○棋譜の入出力ウィンドウに垂直スクロールバーを設置した。

		○Mono環境において一般ユーザー権限だとパスメッセージの出現で落ちるバグを修正した。
		　これによって、root権限で起動する必要がなくなった。
